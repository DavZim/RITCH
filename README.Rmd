---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
options(width = 120)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# RITCH - an R interface to the ITCH Protocol

<!-- badges: start -->
[![R-CMD-check](https://github.com/DavZim/RITCH/workflows/R-CMD-check/badge.svg)](https://github.com/DavZim/RITCH/actions)
<!-- badges: end -->

The `RITCH` library provides an `R` interface to NASDAQs ITCH protocol, which is used to distribute financial messages to participants.
Messages include orders, trades, market status, and much more financial information.
A full list of messages is shown later.

The main purpose of this package is to parse the binary files to a `data.table` in `R`.

The package leverages `Rcpp`/`C++` for efficient message parsing.
As an example, parsing 100 million orders from the `01302020.NASDAQ_ITCH50.gz` NASDAQ sample file (13 GB uncompressed) takes around 30 seconds or 0.3 secs per 1 million orders.

Note that the package provides a small simulated sample dataset in the `ITCH_50` format for testing and example purposes.
Helper functions are provided to list and download sample files from NASDAQs official FTP server.

## Install

To install `RITCH` you can use the following

```R
# stable version:
# not yet available 
# install.packages("RITCH")

# development version:
# install.packages("remotes")
remotes::install_github("DavZim/RITCH")
```

## Quick Overview

The main functions of `RITCH` are read-related and are easily identified by their `read_` prefix.

Due to the inherent structural differences between message classes, each class has its own read function.

Example message classes used in this example are *orders* and *trades*.
First we define the file to load and count the messages in the file, then we read in the orders and the first 100 trades

```{r}
library(RITCH)
file <- system.file("extdata", "ex20101224.TEST_ITCH_50", package = "RITCH")
msg_count <- count_messages(file)
str(msg_count)

orders <- read_orders(file)
str(orders)

trades <- read_trades(file, n_max = 100)
str(trades)
```
Note that the file can be a plain `ITCH_50` file or a gzipped `ITCH_50.gz` file, which will be decompressed to the current directory.

If you want to know more about the functions of the package, read on.

## ITCH Messages

There are a total of 22 different message types which are grouped into 13 classes by `RITCH`.

The messages and their respective classes are:

| Type   | Official Name                                      | `RITCH` class  | `RITCH` read function              | ITCH Section   |  
| -----: | :-----                                             | ---:           | ---:                               | -------------: |  
| `S`    | System Event Message                               |  System Events | `read_system_events()`             | 4.1            |  
| `R`    | Stock Directory                                    |  Stock Directory| `read_stock_directory()`           | 4.2.1          |  
| `H`    | Stock Trading Action                               |  Trading Status| `read_trading_status()`            | 4.2.2          |  
| `Y`    | Reg SHO Short Sale Price Test Restricted Indicator |  Reg SHO       | `read_reg_sho()`                   | 4.2.3          |  
| `L`    | Market Participant Position                        |  Market Participant States | `read_market_participant_states()` | 4.2.4          |  
| `V`    | MWCB Decline Level Message                         |  MWCB          | `read_mwcb()`                      | 4.2.5.1        |  
| `W`    | MWCB Status Message                                |  MWCB          | `read_mwcb()`                      | 4.2.5.2        |  
| `K`    | IPO Quoting Period Update                          |  IPO           | `read_ipo()`                       | 4.2.6          |  
| `J`    | Limit Up - Limit Down (LULD) Auction Collar        |  LULD          | `read_luld()`                      | 4.2.7          |  
| `h`    | Operational Halt                                   |  Trading Status| `read_trading_status()`            | 4.2.8          |  
| `A`    | Add Order - no MPID Attribution                    |  Orders        | `read_orders()`                    | 4.3.1          |  
| `F`    | Add Order with MPID Attribution                    |  Orders        | `read_orders()`                    | 4.3.2          |  
| `E`    | Order Executed Message                             |  Trades        | `read_trades()`                    | 4.4.1          |  
| `C`    | Order Executed with Price Message                  |  Trades        | `read_trades()`                    | 4.4.2          |  
| `X`    | Order Cancel Message                               |  Trades        | `read_trades()`                    | 4.4.3          |  
| `D`    | Order Delete Message                               |  Trades        | `read_trades()`                    | 4.4.4          |  
| `U`    | Order Replace Message                              |  Trades        | `read_trades()`                    | 4.4.5          |  
| `P`    | Trade Message (Non-Cross)                          |  Modifications | `read_modifications()`             | 4.5.1          |  
| `Q`    | Cross Trade Message                                |  Modifications | `read_modifications()`             | 4.5.2          |  
| `B`    | Broken Trade/Order Execution Message               |  Modifications | `read_modifications()`             | 4.5.3          |  
| `I`    | Net Order Imbalance Indicator (NOII) Message       |  NOII          | `read_noii()`                      | 4.6            |  
| `N`    | Retail Price Improvement Indicator (RPII)          |  RPII          | `read_rpii()`                      | 4.7            |  


Note that if you are interested in the exact definition of the messages and its components, you should look into the [official ITCH specification](https://www.nasdaqtrader.com/content/technicalsupport/specifications/dataproducts/NQTVITCHspecification.pdf), which can also be opened by calling `open_itch_specification()`.


## Data

The `RITCH` package provides a small, artificial dataset in the ITCH format for example and testing purposes.
To learn more about the dataset check `?ex20101224.TEST_ITCH_50`.

To access the dataset use:
```{r}
file <- system.file("extdata", "ex20101224.TEST_ITCH_50", package = "RITCH")
count_messages(file, quiet = TRUE)
```
Note that the example dataset does not contain messages from all classes but is limited to 6 system messages, 3 stock directory, 3 stock trading action, 5000 trade, 5000 order, and 2000 order modification messages.
As seen by the 3 stock directory messages, the file contains data about 3 made up stocks (see also the plot later in the Readme).

MASDAQ provides sample ITCH files on their official FTP server at ftp://emi.nasdaq.com/ITCH/ (or in R use `open_itch_ftp()`).

To interact with the sample files, use `list_sample_files()` and `download_sample_files()`.
Note that the sample files are up to 5GB compressed, which inflate to 13GB.

## Notes

There are some tweaks available to deal with memory and speed issues.
For faster reading speeds, you can increase the buffer size of the `read_` functions to something around 1 GB or more (`buffer_size = 1e9`).

If you have to read from a single file multiple times, for example because you want to extract orders and trades, you can count the messages beforehand and provide it to each read's `n_max` argument, reducing the need to pass the file for counting the number of messages.
```{r}
# count messages once
n_msgs <- count_messages(file, quiet = TRUE)

# use counted messages multiple times, saving file passes
orders <- read_orders(file, quiet = TRUE, n_max = n_msgs)
trades <- read_trades(file, quiet = TRUE, n_max = n_msgs)
```

If the dataset does not fit entirely into RAM, you can do a partial read specifying `skip` and `n_max`, similar to this:

```{r}
file <- system.file("extdata", "ex20101224.TEST_ITCH_50", package = "RITCH")

n_messages <- count_orders(count_messages(file, quiet = TRUE))
n_messages

# read 1000 messages at a time
n_batch <- 1000
n_parsed <- 0

while (n_parsed < n_messages) {
  cat(sprintf("Parsing Batch %04i - %04i", n_parsed, n_parsed + n_batch))
  # read in a batch
  df <- read_orders(file, quiet = TRUE, skip = n_parsed, n_max = n_batch)
  cat(sprintf(": with %04i orders\n", nrow(df)))
  # do someting with the data, e.g., save data
  # ...
  n_parsed <- n_parsed + n_batch
}
```

You can also filter a dataset directly while reading messages for `msg_type`, `stock_locate`, `timestamp` range, as well as `stock`. Note that filtering for a specific stock, is just a shorthand lookup for the stocks `stock_locate`s, therefore a `stock_directory` needs to be supplied (either by providing the output from `read_stock_directory()` or `download_stock_locate()`) or the function will try to extract the stock directory from the file.

```{r}
# read in the stock directory as we filter for stock names later on
sdir <- read_stock_directory(file, quiet = TRUE)

od <- read_orders(
  file, 
  filter_msg_type = "A",          # take only no MPID add orders
  min_timestamp = 43200000000000, # start at 12:00:00.000000
  max_timestamp = 55800000000000, # end at 15:30:00.000000
  filter_stock_locate = 1,        # take only stock with code 1
  filter_stock = "CHAR",          # but also take stock CHAR
  stock_directory = sdir          # provide the stock_directory to match stock names to locate_codes
)

od[, .(n = .N), by = msg_type]
range(od$timestamp)
od[, .(n = .N), by = .(locate_code, stock)]
```

If you are interested in writing `ITCH_50` files or gaining a better understanding of the internal data structures, have a look at the `debug` folder and its contents.

### Create a Plot with Trades and Orders of the largest ETFs

As a last step, a quick visualization of the example dataset

```{r ETF_plot}
library(ggplot2)

file <- system.file("extdata", "ex20101224.TEST_ITCH_50", package = "RITCH")

# load the data
orders <- read_orders(file, quiet = TRUE)
trades <- read_trades(file, quiet = TRUE)

# replace the buy-factor with something more useful
orders[, buy := ifelse(buy, "Bid", "Ask")]

ggplot() +
  geom_point(data = orders, 
             aes(x = as.POSIXct(datetime), y = price, color = buy), alpha = 0.2) +
  geom_step(data = trades, aes(x = as.POSIXct(datetime), y = price), size = 0.2) +
  facet_grid(stock~., scales = "free_y") +
  theme_light() +
  labs(title = "Orders and Trades of Three Simulated Stocks",
       subtitle = "Date: 2010-12-24 | Exchange: TEST", 
       caption = "Source: RITCH package", x = "Time", y = "Price", color = "Side") +
  scale_y_continuous(labels = scales::dollar) +
  scale_color_brewer(palette = "Set1")
```

## Open Issues

If you find this package useful or have any other kind of feedback, I'd be happy if you let me know. Otherwise, if you need more functionality, please feel free to create an issue or a pull request. 

Citation and CRAN release are WIP.










Notes on writing ITCH file. 

Heavily optimised (not fully but very good). testfile raw itch 465 KB, gz itch 160KB, files as zipped csvs 249KB, files as tar.gz 247 KB. qs at 184 KB.

With very fast read and write speeds


While writing, only the standard columns are used! WARN if others found.

date and exchange information can be saved in title of file

If you write your data to an ITCH file and want to filter for stocks later on, you need to provide the stock directory either in the file or later in the read!

typical workflow: huge file, extract certain messages to other file (extract stock directory as well)...


